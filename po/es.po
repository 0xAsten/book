msgid ""
msgstr ""
"Project-Id-Version: Building Autonomous Worlds with Dojo\n"
"POT-Creation-Date: 2023-09-28T02:35:48+07:00\n"
"PO-Revision-Date: 2023-08-01 11:08-0300\n"
"Last-Translator: dami <pinonesdamian@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr ""

#: src/SUMMARY.md:4 src/theory/what-is-dojo.md:1
#, fuzzy
msgid "What is Dojo?"
msgstr "## ¿Qué es Dojo?"

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "Teoría AW"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "Ecosistema de Cairo"

#: src/SUMMARY.md:7 src/theory/faqs.md:1
msgid "FAQs"
msgstr ""

#: src/SUMMARY.md:9 src/client/npm/core.md:10 src/misc/contributors.md:12
msgid "Getting Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:11 src/getting-started/quick-start.md:1
msgid "Quick Start"
msgstr ""

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr ""

#: src/SUMMARY.md:13 src/getting-started/setup.md:1
#, fuzzy
msgid "Development Setup"
msgstr "Desarrollo"

#: src/SUMMARY.md:14
#, fuzzy
msgid "Contributing"
msgstr "Colaboradores"

#: src/SUMMARY.md:16
msgid "Community"
msgstr ""

#: src/SUMMARY.md:18 src/community/get-started.md:1
#, fuzzy
msgid "Get Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:20
#, fuzzy
msgid "Architecture"
msgstr "### Arquitectura"

#: src/SUMMARY.md:22 src/cairo/hello-dojo.md:1
msgid "Hello Dojo"
msgstr ""

#: src/SUMMARY.md:23 src/cairo/config.md:1
msgid "Config"
msgstr ""

#: src/SUMMARY.md:24
msgid "World"
msgstr "Mundo"

#: src/SUMMARY.md:25 src/cairo/components.md:1
msgid "Components"
msgstr "Componentes"

#: src/SUMMARY.md:26 src/cairo/systems.md:1
msgid "Systems"
msgstr "Sistemas"

#: src/SUMMARY.md:27 src/cairo/entities.md:1
msgid "Entities"
msgstr "Entidades"

#: src/SUMMARY.md:28 src/cairo/authorization.md:1
msgid "Authorization"
msgstr "Autorización"

#: src/SUMMARY.md:29 src/cairo/commands.md:1
msgid "Commands"
msgstr "Comandos"

#: src/SUMMARY.md:30 src/cairo/events.md:1
msgid "Events"
msgstr ""

#: src/SUMMARY.md:31 src/cairo/testing.md:1
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:32 src/cairo/modules.md:1
msgid "Dojo Modules"
msgstr ""

#: src/SUMMARY.md:33 src/cairo/modules/erc20.md:1
msgid "ERC20"
msgstr ""

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr ""

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr ""

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr ""

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr ""

#: src/SUMMARY.md:40 src/client/overview.md:1
msgid "Overview"
msgstr "Visión general"

#: src/SUMMARY.md:41
msgid "JS"
msgstr ""

#: src/SUMMARY.md:42
msgid "Core"
msgstr ""

#: src/SUMMARY.md:44
#, fuzzy
msgid "Toolchain"
msgstr "### Herramientas"

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr ""

#: src/SUMMARY.md:47 src/toolchain/sozo/overview.md:1
msgid "Sozo"
msgstr ""

#: src/SUMMARY.md:48 src/SUMMARY.md:60 src/SUMMARY.md:62
#, fuzzy
msgid "Reference"
msgstr "Referencias"

#: src/SUMMARY.md:49
msgid "init"
msgstr ""

#: src/SUMMARY.md:50
msgid "build"
msgstr ""

#: src/SUMMARY.md:51
msgid "test"
msgstr ""

#: src/SUMMARY.md:52
msgid "migrate"
msgstr ""

#: src/SUMMARY.md:53
msgid "execute"
msgstr ""

#: src/SUMMARY.md:54
msgid "register"
msgstr ""

#: src/SUMMARY.md:55
msgid "system"
msgstr ""

#: src/SUMMARY.md:56
msgid "component"
msgstr ""

#: src/SUMMARY.md:57
msgid "events"
msgstr ""

#: src/SUMMARY.md:58
msgid "auth"
msgstr ""

#: src/SUMMARY.md:59 src/toolchain/katana/overview.md:1
msgid "Katana"
msgstr ""

#: src/SUMMARY.md:61
msgid "Torii"
msgstr ""

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr ""

#: src/SUMMARY.md:66
msgid "Locally"
msgstr ""

#: src/SUMMARY.md:67
msgid "Remote"
msgstr ""

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr ""

#: src/SUMMARY.md:72 src/tutorial/onchain-chess/0-setup.md:1
#, fuzzy
msgid "0. Setup"
msgstr "Configuración"

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr ""

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr ""

#: src/SUMMARY.md:75 src/tutorial/onchain-chess/3-legal.md:1
msgid "3. Check Legal Move"
msgstr ""

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr ""

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr "Colaboradores"

#: src/index.md:1
msgid "![Dojo](images/dojo-mark-full-dark.svg)"
msgstr ""

#: src/index.md:3
#, fuzzy
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo es un proyecto de código abierto, actualmente en su fase inicial de "
"desarrollo, y da una cálida bienvenida a los colaboradores. Para obtener "
"recursos adicionales, encuentra el libro en [Github](https://github.com/"
"dojoengine/book)."

#: src/index.md:7
#, fuzzy
msgid "Dojo: The Provable Game Engine"
msgstr "## Dojo: El motor de juegos demostrables"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""

#: src/index.md:11
#, fuzzy
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the [Theory](./theory/"
"autonomous-worlds.md) elucidates this emergent concept of autonomous worlds "
"and Provable games."
msgstr ""
"Esta guía está dedicada a familiarizarte con el motor de Dojo y el potencial "
"transformador de los juegos demostrables. Una sección especial sobre la "
"[Teoría](./theory/autonomous-worlds.md) que aclara este emergente concepto "
"de mundos autónomos y juegos probables."

#: src/index.md:13
msgid "[Quickstart](./getting-started/quick-start.md)"
msgstr ""

#: src/index.md:14
msgid "[What is Dojo? ](./theory/what-is-dojo.md)"
msgstr ""

#: src/index.md:15
msgid "[Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""

#: src/index.md:18
msgid "Explainer"
msgstr ""

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://"
"twitter.com/tarrenceva) explaining how Dojo works at the 2023 [Autonomous "
"Anonymous Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""
"Aquí tienes un video de [Cartridge](https://cartridge.gg/) donde [Tarrence]"
"(https://twitter.com/tarrenceva) explica cómo funciona Dojo en la "
"[Autonomous Anonymous Summit 2023](https://twitter.com/pet3rpan_/"
"status/1666764726427353091):"

#: src/index.md:30
#, fuzzy
msgid "Organizational Structure"
msgstr "### Estructura Organizacional"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO]"
"(https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many "
"more [contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojo es una iniciativa de código abierto, con licencia MIT, dedicada a "
"promover y avanzar en el concepto de Mundos Autónomos (AWs). Es liderado por "
"[Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO](https://"
"bibliothecadao.xyz/), [briq](https://briq.construction/) y muchos otros "
"[colaboradores](https://github.com/orgs/dojoengine/people)."

#: src/index.md:33
#, fuzzy
msgid "How do I get involved?"
msgstr "### ¿Cómo puedo involucrarme?"

#: src/index.md:35
#, fuzzy
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) and "
"[contribution guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""
"Visita nuestro [Github](https://github.com/dojoengine), [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) y [guía "
"de contribución](https://book.dojoengine.org/misc/contributors.html!)."

#: src/theory/what-is-dojo.md:3
#, fuzzy
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [on-"
"chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""
"Dojo es el resultado de las lecciones aprendidas de intentos de construir "
"[juegos en cadena](https://naavik.co/digest/primer-fully-on-chain-gaming), "
"un sector emergente en la industria de los videojuegos. Cualquier "
"desarrollador que haya intentado crear un juego en cadena aprecia los "
"desafíos de ingeniería inherentes, una realidad que nos impulsó a crear "
"Dojo. Así como no recrearías Unity cada vez que desarrollas un nuevo juego, "
"el mismo principio se aplica aquí. Dojo está diseñado para manejar la "
"infraestructura compleja, permitiendo a los desarrolladores enfocarse en los "
"aspectos únicos de sus juegos."

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""

#: src/theory/what-is-dojo.md:9
msgid "Stop building infrastructure; start building games"
msgstr ""

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-"
"chain games. It includes:"
msgstr ""

#: src/theory/what-is-dojo.md:13
msgid "Entity Component System (ECS)"
msgstr ""

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""

#: src/theory/what-is-dojo.md:17
#, fuzzy
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""
"Dojo utiliza el ECS (Sistema de Componentes de Entidades) como un patrón "
"arquitectónico para gestionar, organizar eficientemente el estado y el "
"comportamiento de los Mundos Autónomos (AWs). En este patrón, la computación "
"se define como una lista de sistemas que operan sobre un conjunto de "
"entidades, cada una de las cuales consta de un conjunto dinámico de "
"componentes de datos puros. Los sistemas seleccionan las entidades a "
"procesar mediante consultas persistentes y eficientes sobre los componentes "
"de las entidades."

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr ""

#: src/theory/what-is-dojo.md:21
msgid "[Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr ""

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-"
"chain games. It also eliminates the need to manually create indexers, which "
"can be a tedious and error-prone process."
msgstr ""

#: src/theory/what-is-dojo.md:27
msgid "[Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr ""

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""

#: src/theory/what-is-dojo.md:31
msgid "[Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr ""

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""

#: src/theory/what-is-dojo.md:35
msgid "What Dojo doesn't give you"
msgstr ""

#: src/theory/what-is-dojo.md:37
msgid ""
"Visual graphics - While Dojo provides networking and contracts, it doesn't "
"offer graphical engines. You can bring your graphics of choice! Integrate "
"your Dojo world with Unreal, Godot, or Unity."
msgstr ""

#: src/theory/what-is-dojo.md:39
msgid "Understanding the Dojo Workflow: A Visual Guide"
msgstr ""

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""

#: src/theory/what-is-dojo.md:45
msgid "![Dojo Sozo Workflow](../images/dojo-sozo-workflow.jpg)"
msgstr ""

#: src/theory/autonomous-worlds.md:1
#, fuzzy
msgid "Autonomous Worlds"
msgstr "## Mundos Autónomos"

#: src/theory/autonomous-worlds.md:3
#, fuzzy
msgid ""
"\"Autonomous worlds represent persistent, permissionless, and decentralized "
"open environments that users can freely interact with and contribute to.\""
msgstr ""
"> \"Los mundos autónomos representan entornos abiertos, persistentes, sin "
"permisos y descentralizados, en los que los usuarios pueden interactuar y "
"contribuir libremente.\""

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""
"La definición precisa de los Mundos Autónomos (AWs, por sus siglas en "
"inglés) sigue siendo algo escurridiza, ya que es más bien un concepto "
"abstracto que aún no se ha cristalizado completamente. Lattice [introdujo]"
"(https://0xparc.org/blog/autonomous-worlds)  por primera vez el término en "
"2022, pero la noción de mundos abiertos que operan en la cadena de bloques "
"ha existido durante un tiempo. La abstracción presentada por MUD sirvió como "
"un catalizador para que el mercado reconociera el potencial de estos mundos."

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""
"Los Mundos Autónomos comparten similitudes destacadas con las cadenas de "
"bloques en su naturaleza fundamental. Una vez establecidos, persisten y "
"mantienen su estado a lo largo de la vida útil de la cadena. Los jugadores "
"pueden unirse o salir, y los desarrolladores pueden ampliar estos mundos "
"desplegando características de manera sin permisos, de manera similar a cómo "
"se añaden contratos a una cadena. Aunque no existe una definición "
"universalmente aceptada para un Mundo Autónomo, creemos que un juego debe "
"poseer al menos las siguientes dos características esenciales para ser "
"considerado como tal:"

#: src/theory/autonomous-worlds.md:9
#, fuzzy
msgid ""
"Decentralized data availability layer: While the state execution may reside "
"on a centralized layer, it is crucial that the state can be reconstructed if "
"the execution layer ceases to exist. Rollups offer a solution, providing "
"increased capacity execution layers while ensuring data is permanently "
"settled on Ethereum. This guarantees the world's perpetual persistence."
msgstr ""
"1. Capa de disponibilidad de datos descentralizada: Si bien la ejecución del "
"estado puede residir en una capa centralizada, es crucial que el estado "
"pueda reconstruirse si la capa de ejecución deja de existir. Los Rollups "
"ofrecen una solución al proporcionar capas de ejecución con mayor capacidad "
"mientras aseguran que los datos se asienten permanentemente en Ethereum. "
"Esto garantiza la persistencia perpetua del mundo.\n"
"\n"
"2. Punto de entrada sin permisos para expandir el mundo: El contrato del "
"Mundo debe ser capaz de aceptar nuevos sistemas y componentes sin requerir "
"permiso. Si bien esto no implica que cada componente y sistema se utilizará, "
"deben adherirse a este patrón, garantizando un acceso abierto e irrestricto "
"para posibles mejoras."

#: src/theory/autonomous-worlds.md:11
#, fuzzy
msgid ""
"Permissionless entry point for expanding the world: The World contract must "
"be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""
"1. Capa de disponibilidad de datos descentralizada: Si bien la ejecución del "
"estado puede residir en una capa centralizada, es crucial que el estado "
"pueda reconstruirse si la capa de ejecución deja de existir. Los Rollups "
"ofrecen una solución al proporcionar capas de ejecución con mayor capacidad "
"mientras aseguran que los datos se asienten permanentemente en Ethereum. "
"Esto garantiza la persistencia perpetua del mundo.\n"
"\n"
"2. Punto de entrada sin permisos para expandir el mundo: El contrato del "
"Mundo debe ser capaz de aceptar nuevos sistemas y componentes sin requerir "
"permiso. Si bien esto no implica que cada componente y sistema se utilizará, "
"deben adherirse a este patrón, garantizando un acceso abierto e irrestricto "
"para posibles mejoras."

#: src/theory/autonomous-worlds.md:13
#, fuzzy
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""
"Somos firmes creyentes en el potencial de los Mundos Autónomos para "
"catalizar la exploración de nuevas formas en el medio proporcionado por las "
"pruebas zk y la tecnología blockchain. Esto no se trata solo de juegos, sino "
"también de nuevas formas de arte, coordinación, diversión, surgidas de "
"experimentar e innovar radicalmente, cuestionando en última instancia la "
"misma noción de \"jugar\" en este valiente y descentralizado mundo sin "
"confianza."

#: src/theory/autonomous-worlds.md:15
#, fuzzy
msgid "Homework"
msgstr "### Tarea"

#: src/theory/autonomous-worlds.md:16
msgid ""
"[Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)"
msgstr ""

#: src/theory/autonomous-worlds.md:17
msgid ""
"[0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:18
msgid ""
"[Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)"
msgstr ""

#: src/theory/autonomous-worlds.md:19
msgid ""
"[Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:20
msgid "[Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)"
msgstr ""

#: src/theory/autonomous-worlds.md:21
msgid ""
"[Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)"
msgstr ""

#: src/theory/autonomous-worlds.md:22
msgid ""
"[Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-"
"worlds/)"
msgstr ""

#: src/theory/autonomous-worlds.md:23
msgid ""
"[Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-"
"chain-realities-and-autonomous-worlds)"
msgstr ""

#: src/theory/cairo.md:1
msgid "Provable games"
msgstr ""

#: src/theory/cairo.md:3
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-"
"knowledge-proofs/) properties for efficient scaling and verification of "
"computations. [Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) "
"addresses this need by providing a generalized language, eliminating the "
"complexity of creating circuits to incorporate [SNARKs](https://consensys."
"net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""
"Los juegos demostrables requieren propiedades de [conocimiento cero](https://"
"ethereum.org/en/zero-knowledge-proofs/)(ZK) para una escalabilidad eficiente "
"y verificación de cálculos. [Cairo](https://book.starknet.io/chapter_1/"
"what_is_cairo.html) aborda esta necesidad proporcionando un lenguaje "
"generalizado, eliminando la complejidad de crear circuitos para incorporar "
"[SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/). "

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr ""
"**Puedes simplemente programar en Cairo y tus aplicaciones se vuelven "
"automáticamente demostrables**. "

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), "
"which is compatible with Starknet's Layer 2, Starknet appchains, and even in-"
"browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK "
"primitives to fuel your game development."
msgstr ""
"Además, puedes implementar tus programas en la [Máquina Virtual Cairo]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), que "
"es compatible con la Capa 2 de Starknet, las appchains de Starknet e incluso "
"en el navegador a través de WebAssembly (WASM). Dojo tiene como objetivo "
"proporcionar primitivas de conocimiento cero sencillas(ZK) para impulsar el "
"desarrollo de tus juegos."

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""
"Para obtener más información sobre Starknet, Cairo y su stack tecnológico, "
"visita el [libreo de Starknet y Cairo](https://book.starknet.io/)."

#: src/theory/cairo.md:11 src/getting-started/setup.md:8
msgid "Cairo"
msgstr ""

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""
"Cairo es un lenguaje de contratos inteligentes de código abierto y Turing "
"completo, desarrollado por Starkware, diseñado para impulsar el Validity "
"Rollup Starknet. El lenguaje permite una computación altamente expresiva y "
"verificable, lo que lo hace adecuado para construir aplicaciones escalables "
"y seguras, incluidos proyectos de finanzas descentralizadas (DeFi)"

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""
"Dojo se basa en Cairo al crear un framework para desarrollar Mundos "
"Autonomos (AWs). Al aprovechar las capacidades de Cairo, Dojo tiene como "
"objetivo agilizar el proceso de desarrollo, mejorar la mantenibilidad y "
"mejorar el rendimiento de AWs."

#: src/theory/cairo.md:17
#, fuzzy
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/"
"commands.md). Commands are a design pattern that helps to reduce boilerplate "
"code, resulting in cleaner and more maintainable applications. They achieve "
"this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Una característica clave del Dojo framework es el uso de [comandos](../"
"framework/cairo/commands.md). Los comandos son un patrón de diseño que ayuda "
"a reducir el código repetitivo, lo que resulta en aplicaciones más limpias y "
"fáciles de mantener. Logran esto encapsulando acciones u operaciones "
"específicas dentro de unidades autocontenidas y reutilizables."

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""
"Los desarrolladores pueden escribir comandos libremente dentro de los "
"Sistemas, y el compilador de Cairo se encarga de enlazar las funciones "
"apropiadas. "

#: src/theory/cairo.md:21
#, fuzzy
msgid "Essential Reading"
msgstr "#### Lectura Esencial"

#: src/theory/cairo.md:22
msgid "[Cairo book](https://cairo-book.github.io/)"
msgstr ""

#: src/theory/cairo.md:23
msgid "[Awesome Cairo](https://github.com/auditless/awesome-cairo)"
msgstr ""

#: src/theory/cairo.md:24
msgid "[Starknet Book](https://book.starknet.io/)"
msgstr ""

#: src/theory/cairo.md:26
#, fuzzy
msgid "Starknet as an L2"
msgstr "### Starknet como una L2"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknet es una solución de Capa 2 (L2) de Validity Rollup diseñada para "
"escalar Ethereum. Opera ofreciendo una alta capacidad de transacciones y "
"bajos costos de gas, manteniendo el mismo nivel de seguridad que Ethereum "
"Capa 1 (L1). La estrategia que utiliza es similar a resolver un rompecabezas "
"Sudoku: verificar una solución es más fácil que encontrar la solución desde "
"cero. De manera similar, Starknet reemplaza la computación pesada y costosa "
"en L1 con una verificación más económica en L1 mediante el uso de pruebas "
"STARK calculadas fuera de la cadena."

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""
"En términos más técnicos, Starknet es un Validity-Rollup sin permisos "
"(también conocido como \"ZK-Rollup\") que admite computación general y "
"actualmente funciona como una red L2 sobre Ethereum. La seguridad de la red "
"L1 está garantizada por su utilización del sistema de prueba criptográfica "
"STARK, que se considera uno de los más seguros y escalables."

#: src/theory/cairo.md:32
#, fuzzy
msgid "Starknet as an Appchain"
msgstr "### Starknet como una Appchain"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-"
"Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, and "
"appchains. Remarkably, you can also run it in WebAssembly (WASM) to generate "
"proofs on the client-side! The Dojo team is working closely with the [Madara]"
"(https://github.com/keep-starknet-strange/madara) team to enable Starknet "
"appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairo es un lenguaje isomórfico de propósito general, optimizado para "
"pruebas de conocimiento cero (ZK). Es la fuerza impulsora detrás de "
"Starknet, Starkex y las appchains. Sorprendentemente, también se puede "
"ejecutar en WebAssembly (WASM) para generar pruebas en el lado del cliente! "
"El equipo de Dojo está trabajando en estrecha colaboración con el equipo de "
"[Madara](https://github.com/keep-starknet-strange/madara) para permitir que "
"las appchains de Starknet ejecuten sin problemas los mundos de Dojo."

#: src/theory/faqs.md:3
#, fuzzy
msgid "Who owns Dojo?"
msgstr "## ¿Qué es Dojo?"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""

#: src/theory/faqs.md:7
#, fuzzy
msgid "Why Dojo?"
msgstr "### ¿Por qué Dojo?"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""

#: src/theory/faqs.md:11
#, fuzzy
msgid "What is the Dojo roadmap?"
msgstr "## ¿Qué es Dojo?"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) and join the [Discord](https://"
"discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas for the project, "
"please open an issue."
msgstr ""

#: src/theory/faqs.md:15
msgid "What is an onchain game?"
msgstr ""

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""

#: src/theory/faqs.md:19
#, fuzzy
msgid "What is an autonomous world?"
msgstr "## Mundos Autónomos"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous Worlds](../theory/"
"autonomous-worlds.md)."
msgstr ""

#: src/theory/faqs.md:23
#, fuzzy
msgid "What is Cairo?"
msgstr "## ¿Qué es Dojo?"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a low-"
"level language designed to compile to the Cairo Virtual Machine. Learn more "
"about it here: [Cairo](../theory/cairo.md)."
msgstr ""

#: src/theory/faqs.md:27
msgid "What is a provable game?"
msgstr ""

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""

#: src/getting-started/quick-start.md:3
msgid ""
"It is worth reading [theory](../theory/autonomous-worlds.md) to familiarize "
"yourself with the concept of Autonomous Worlds (AWs) and the [Cairo "
"ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""

#: src/getting-started/quick-start.md:6
#, fuzzy
msgid "Install Dojoup"
msgstr "Instalación"

#: src/getting-started/quick-start.md:8
#, fuzzy
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup [here](https://github.com/dojoengine/dojo/blob/master/dojoup/README."
"md)."
msgstr ""
"Dojoup es el instalador de la herramienta Dojo. Puedes encontrar más "
"información sobre él [aquí](https://github.com/dojoengine/dojo/blob/master/"
"dojoup/README.md)."

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""

#: src/getting-started/quick-start.md:14
#, fuzzy
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen, "
"which will make the `dojoup` command available in your CLI."
msgstr ""
"Esto instalará Dojoup, luego simplemente sigue las instrucciones que "
"aparecen en pantalla,\n"
"lo que hará que el comando `dojoup` esté disponible en tu línea de comandos "
"(CLI)."

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup."
"md)."
msgstr ""

#: src/getting-started/quick-start.md:23
msgid "Next steps"
msgstr ""

#: src/getting-started/quick-start.md:25
msgid ""
"Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""

#: src/getting-started/from-source.md:1
#, fuzzy
msgid "Building from source"
msgstr "### Compilando desde el código fuente"

#: src/getting-started/from-source.md:3
msgid ""
"If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""

#: src/getting-started/from-source.md:5 src/getting-started/setup.md:5
#, fuzzy
msgid "Prerequisites"
msgstr "## Requisitos previos"

#: src/getting-started/from-source.md:7
#, fuzzy
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager. The easiest way to install both is with [`rustup.rs`]"
"(https://rustup.rs/)."
msgstr ""
"Necesitarás el compilador de [Rust](https://rust-lang.org) y Cargo, el "
"gestor de paquetes de Rust.\n"
"La forma más sencilla de instalar ambos es utilizando [`rustup.rs`](https://"
"rustup.rs/)."

#: src/getting-started/from-source.md:10
#, fuzzy
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://"
"visualstudio.microsoft.com/downloads/), installed with the \"Desktop "
"Development With C++\" Workloads option."
msgstr ""
"En Windows, también necesitarás una versión reciente de [Visual Studio]"
"(https://visualstudio.microsoft.com/downloads/),\n"
"instalada con la opción \"Desarrollo de escritorio con C++\" en las cargas "
"de trabajo."

#: src/getting-started/from-source.md:13
#, fuzzy
msgid "Building"
msgstr "#### Compilando"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "Puedes utilizar las diferentes opciones de [Dojoup](#using-dojoup):"

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "O bien, utilizando un solo comando de Cargo:"

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://"
"github.com/dojoengine/dojo):"
msgstr ""
"O bien, construyendo manualmente desde una copia local del [repositorio de "
"Dojo](https://github.com/dojoengine/dojo):"

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""

#: src/getting-started/setup.md:3
msgid ""
"This article is a guide to setting up a development environment for Dojo. It "
"is not suggested to follow this guide if you are just wanting to play with "
"the toolchain. We strongly suggest following the [Quick Start](../getting-"
"started/quick-start.md) guide."
msgstr ""

#: src/getting-started/setup.md:7
msgid "Rust"
msgstr ""

#: src/getting-started/setup.md:12
msgid "Guide"
msgstr ""

#: src/getting-started/setup.md:14
msgid "Clone"
msgstr ""

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""

#: src/getting-started/setup.md:20
msgid "Linux & Mac"
msgstr ""

#: src/getting-started/setup.md:22
#, fuzzy
msgid "1. Install Rust and Dependencies"
msgstr "#### 1. Instalar Rust y dependencias"

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr ""
"Comienza instalando Rust y ejecutando el conjunto de pruebas para confirmar "
"la configuración:"

#: src/getting-started/setup.md:30
#, fuzzy
msgid ""
"Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""
"> Nota: Dependiendo de la distribución de Linux que estés usando, es posible "
"que necesites instalar dependencias adicionales. Asegúrate de instalar todas "
"las dependencias sugeridas o faltantes que surjan durante el proceso de "
"configuración."

#: src/getting-started/setup.md:32
#, fuzzy
msgid "2. Install Scarb Package Manager"
msgstr "#### 2. Instalar el administrador de paquetes Scarb"

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""
"Luego, instala el gestor de paquetes [Scarb](https://docs.swmansion.com/"
"scarb) ejecutando el siguiente comando:"

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""

#: src/getting-started/setup.md:40
#, fuzzy
msgid "3. Add the Cairo 1.0 VSCode Extension"
msgstr "#### 3. Configura la extensión de Cairo para Visual Studio Code"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) extension for Visual Studio Code."
msgstr ""

#: src/getting-started/setup.md:45
msgid "Windows"
msgstr ""

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "_Próximamente_"

#: src/getting-started/setup.md:49
#, fuzzy
msgid "Container"
msgstr "### Contenedor"

#: src/getting-started/contributing.md:1
#, fuzzy
msgid "Contributing to the Core"
msgstr "## Contribuyendo al Libro de Dojo"

#: src/getting-started/contributing.md:3
#, fuzzy
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""
"> Dojo es un proyecto de código abierto, actualmente en su fase inicial de "
"desarrollo, y da una cálida bienvenida a los colaboradores. Para obtener "
"recursos adicionales, encuentra el libro en [Github](https://github.com/"
"dojoengine/book)."

#: src/getting-started/contributing.md:5
#, fuzzy
msgid "How to Contribute"
msgstr "### Formas de contribuir"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""

#: src/community/get-started.md:3
msgid ""
"[Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)"
msgstr ""

#: src/community/get-started.md:4
msgid "[Discord](https://discord.gg/KG9w9BmDrV)"
msgstr ""

#: src/community/get-started.md:5
msgid "[Twitter](https://twitter.com/dojostarknet)"
msgstr ""

#: src/community/get-started.md:6
msgid "[Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""

#: src/cairo/hello-dojo.md:3
msgid ""
"This section assumes that you have already installed the Dojo toolchain and "
"are familiar with Cairo. If not, please refer to the [Getting Started](../"
"getting-started/quick-start.md) section."
msgstr ""

#: src/cairo/hello-dojo.md:5
#, fuzzy
msgid "Dojo in 15 Minutes"
msgstr "Motor de Dojo"

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""

#: src/cairo/hello-dojo.md:19
msgid "Anatomy of a Dojo Project"
msgstr ""

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr ""

#: src/cairo/hello-dojo.md:54
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we _must_ include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr ""

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr ""

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr ""

#: src/cairo/hello-dojo.md:142
msgid "Explained the anatomy of a Dojo project"
msgstr ""

#: src/cairo/hello-dojo.md:143
msgid ""
"Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute"
msgstr ""

#: src/cairo/hello-dojo.md:144
msgid "Explained the `execute` function"
msgstr ""

#: src/cairo/hello-dojo.md:145
msgid "Explained the `Context` struct"
msgstr ""

#: src/cairo/hello-dojo.md:146
msgid "Touched on the `get!` and `set!` commands"
msgstr ""

#: src/cairo/hello-dojo.md:149
msgid "Run it locally!"
msgstr ""

#: src/cairo/hello-dojo.md:151
msgid ""
"Now that we have some theory out of the way, lets build the Dojo project!"
msgstr ""

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr ""

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""

#: src/cairo/hello-dojo.md:221
msgid "Indexing"
msgstr ""

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr ""

#: src/cairo/hello-dojo.md:233
msgid "Built a Dojo world"
msgstr ""

#: src/cairo/hello-dojo.md:234
msgid "Deployed the project to Katana"
msgstr ""

#: src/cairo/hello-dojo.md:235
msgid "Ran the spawn system locally"
msgstr ""

#: src/cairo/hello-dojo.md:236
msgid "Indexed the world with Torii"
msgstr ""

#: src/cairo/hello-dojo.md:238
msgid "Next Steps"
msgstr ""

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a [Scarb]"
"(https://docs.swmansion.com/scarb/) file which is an excellent Cairo package "
"manager and project manager."
msgstr ""

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr ""

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""

#: src/cairo/world.md:1
#, fuzzy
msgid "World Contract"
msgstr "Comandos del Mundo"

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""
"El contrato del mundo funciona como el núcleo central del sistema, sirviendo "
"como base para iniciar y resolver todas las interacciones. Dentro de este "
"núcleo, se despliegan, registran y ejecutan contratos, agilizando el proceso "
"para los sistemas secundarios al permitir que los clientes interactúen con "
"un solo contrato en lugar de potencialmente cientos."

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""

#: src/cairo/world.md:8
#, fuzzy
msgid ""
"**To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""
"> **Para tener en cuenta:** Considera los Mundos Autónomos como blockchains "
"soberanas que residen dentro de otra blockchain, una blockchain anidada, por "
"así decirlo. Así como puedes desplegar contratos en Ethereum para mejorar su "
"funcionalidad, de manera similar puedes introducir sistemas en el contrato "
"del Mundo para enriquecer sus características. Si bien cualquiera puede "
"contribuir al Mundo, al igual que en Ethereum, se requiere autorización para "
"interactuar con el estado de los componentes. Existe un tema dedicado a la "
"Autorización."

#: src/cairo/world.md:11
msgid "Context"
msgstr ""

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""

#: src/cairo/world.md:25
msgid "The `uuid()` command"
msgstr ""

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""

#: src/cairo/world.md:29 src/cairo/commands.md:20 src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr ""

#: src/cairo/world.md:36
msgid "Full World API"
msgstr ""

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:3
#, fuzzy
msgid "Components = Data"
msgstr "Componentes"

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""
"Al diseñar los componentes de un mundo, es crucial considerar cuidadosamente "
"las abstracciones que se crean, manteniendo siempre en mente la "
"composabilidad."

#: src/cairo/components.md:10
#, fuzzy
msgid "Components are Structs"
msgstr "Componentes"

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""

#: src/cairo/components.md:23
msgid "The #\\[key\\] attribute"
msgstr ""

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""

#: src/cairo/components.md:53
msgid "Implementing Traits"
msgstr ""

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""

#: src/cairo/components.md:77
msgid "Custom Setting Components"
msgstr ""

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""

#: src/cairo/components.md:94
msgid "Types"
msgstr ""

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr ""

#: src/cairo/components.md:98
msgid "`u8`"
msgstr ""

#: src/cairo/components.md:99
msgid "`u16`"
msgstr ""

#: src/cairo/components.md:100
msgid "`u32`"
msgstr ""

#: src/cairo/components.md:101
msgid "`u64`"
msgstr ""

#: src/cairo/components.md:102
msgid "`u128`"
msgstr ""

#: src/cairo/components.md:103
msgid "`u256`"
msgstr ""

#: src/cairo/components.md:104
msgid "`ContractAddress`"
msgstr ""

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr ""

#: src/cairo/components.md:109
msgid "In practice with modularity in mind"
msgstr ""

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr ""

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:218
#, fuzzy
msgid ""
"A complete example can be found in the [Dojo Starter](https://github.com/"
"dojoengine/dojo-starter)"
msgstr ""
"O bien, construyendo manualmente desde una copia local del [repositorio de "
"Dojo](https://github.com/dojoengine/dojo):"

#: src/cairo/systems.md:3
#, fuzzy
msgid "Systems = Logic"
msgstr "Sistemas"

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr ""

#: src/cairo/systems.md:31
msgid "The Execute function"
msgstr ""

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""

#: src/cairo/systems.md:35
msgid "Other functions in a System"
msgstr ""

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""

#: src/cairo/systems.md:39
msgid "Using View Functions"
msgstr ""

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr ""

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr ""

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr ""

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this link]"
"(https://github.com/dojoengine/dojo-examples), illustrates how to implement "
"a view function:"
msgstr ""

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr ""

#: src/cairo/systems.md:80
msgid ""
"**Using Dojo Core**: If you are working within the [Dojo Core](../client/npm/"
"core.md), utilize the `call` function. "
msgstr ""

#: src/cairo/systems.md:82
msgid ""
"**For Rust Users**: The [Starkli](https://book.starkli.rs/) library provides "
"a handy method to invoke view functions in Rust."
msgstr ""

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""

#: src/cairo/systems.md:86
msgid "System Authentication"
msgstr ""

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""

#: src/cairo/entities.md:3
msgid ""
"Entities are the primary key value within the world, to which components can "
"be attached."
msgstr ""

#: src/cairo/entities.md:5
#, fuzzy
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""
"Una idea errónea común para aquellos que son nuevos en los sistemas ECS es "
"la forma en que las entidades existen dentro del mundo. Diferentes sistemas "
"ECS manejan las entidades de diversas formas. En Dojo, las entidades se "
"tratan como un valor de clave primaria dentro del mundo, a la cual se pueden "
"adjuntar componentes. Para ilustrar este concepto, consideremos un ejemplo "
"sencillo de un personaje en un juego que tiene un componente de posición y "
"un componente de salud."

#: src/cairo/entities.md:7
#, fuzzy
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""
"Al definir los componentes para esta entidad, es importante tener en cuenta "
"que no hacemos referencia directa a la entidad. En su lugar, simplemente "
"proporcionamos dos estructuras que contendrá la entidad. Este enfoque "
"enfatiza la flexibilidad y la composabilidad del sistema ECS, lo que permite "
"la fácil creación y modificación de entidades con diversas combinaciones de "
"componentes."

#: src/cairo/entities.md:26
#, fuzzy
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the `ctx."
"origin` to reference the current entity."
msgstr ""
"Ahora, creemos un `SpawnSystem` para el personaje. Es importante tener en "
"cuenta que no hemos definido explícitamente una entidad en ningún lugar. En "
"su lugar, el sistema asignará un ID de clave primaria a la entidad cuando se "
"ejecute este sistema."

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr ""

#: src/cairo/entities.md:58
#, fuzzy
msgid ""
"ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-"
"FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""
"Vale la pena leer esta excelente [FAQ](https://github.com/SanderMertens/ecs-"
"faq) sobre el ECS"

#: src/cairo/authorization.md:3
msgid ""
"Authorization is crucial to a world, just like how authorization is crucial "
"to any smart contract."
msgstr ""

#: src/cairo/authorization.md:5
#, fuzzy
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""
"Como se discutió en el capítulo [World](./world.md), los Mundos Autónomos "
"(AWs) funcionan como cadenas soberanas anidadas dentro de una cadena pública "
"de bloques. Estos Mundos también están abiertos al público. Esta estructura "
"permite que cualquier persona mejore un Mundo mediante el despliegue de "
"componentes o sistemas. Sin embargo, esta apertura también conlleva "
"consideraciones de seguridad. Al igual que en Ethereum, interactuar con el "
"estado de un componente mediante un Sistema requiere una autorización "
"adecuada por parte del propietario del componente."

#: src/cairo/authorization.md:7
#, fuzzy
msgid "Auth Architecture"
msgstr "### Arquitectura"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""

#: src/cairo/authorization.md:11
msgid "![Authorization Architecture](../images/dojo-auth.png)"
msgstr ""

#: src/cairo/authorization.md:13
#, fuzzy
msgid "Providing Authorization"
msgstr "Autorización"

#: src/cairo/authorization.md:15
msgid ""
"The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr ""

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""
"Entender los comandos es clave para comprender Dojo. Los utilizarás "
"ampliamente en los sistemas que diseñes."

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""
"Los comandos en Dojo son funciones generalizadas que se expanden en tiempo "
"de compilación para facilitar la ejecución de sistemas. Proporcionan una "
"forma conveniente para que los sistemas interactúen con el estado del mundo "
"al abstraer operaciones comunes, como obtener o actualizar componentes, y "
"generar IDs únicos. Al aprovechar estos comandos, los desarrolladores pueden "
"simplificar sus implementaciones de sistemas y mejorar la legibilidad del "
"código."

#: src/cairo/commands.md:8
#, fuzzy
msgid "Using commands"
msgstr "Comandos de sozo"

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""

#: src/cairo/commands.md:16
msgid "The `get!` command"
msgstr ""

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr ""

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""

#: src/cairo/commands.md:30
msgid "The `set!` command"
msgstr ""

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr ""

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""

#: src/cairo/commands.md:52
msgid "The `emit!` command"
msgstr ""

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr ""

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/"
"overview.md), all these events are seamlessly indexed, ensuring easy and "
"efficient querying."
msgstr ""

#: src/cairo/events.md:6
#, fuzzy
msgid "Component Events"
msgstr "Componentes"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr ""

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""

#: src/cairo/events.md:43
#, fuzzy
msgid "World Events"
msgstr "Comandos del Mundo"

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""

#: src/cairo/events.md:74
#, fuzzy
msgid "Custom Events"
msgstr "Componentes"

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr ""

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr ""

#: src/cairo/events.md:107
msgid ""
"Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr ""

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr ""

#: src/cairo/testing.md:14
msgid "Writing Unit Tests"
msgstr ""

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the Component/"
"System you are writing."
msgstr ""

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the [dojo-starter](https://github."
"com/dojoengine/dojo-starter):"
msgstr ""

#: src/cairo/testing.md:20
#, fuzzy
msgid "`components.cairo`"
msgstr "Componentes"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""

#: src/cairo/testing.md:52
msgid "Writing Integration Tests"
msgstr ""

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""

#: src/cairo/testing.md:56
#, fuzzy
msgid ""
"This is the example from the [dojo-starter](https://github.com/dojoengine/"
"dojo-starter):"
msgstr ""
"O bien, construyendo manualmente desde una copia local del [repositorio de "
"Dojo](https://github.com/dojoengine/dojo):"

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr ""

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/testing.md:113
msgid "Useful Dojo Test Functions"
msgstr ""

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""

#: src/cairo/modules.md:5
#, fuzzy
msgid "Module Architecture"
msgstr "### Arquitectura"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""

#: src/cairo/modules/erc20.md:5
msgid "Integration into Your World"
msgstr ""

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr ""

#: src/client/overview.md:7
msgid "[npm](./npm.md)"
msgstr ""

#: src/client/npm.md:1
msgid "Javascript Libraries"
msgstr ""

#: src/client/npm.md:3
msgid ""
"Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""

#: src/client/npm.md:5
msgid "Examples using these:"
msgstr ""

#: src/client/npm.md:7
msgid ""
"[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""

#: src/client/npm.md:8
msgid ""
"[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""

#: src/client/npm.md:10 src/client/npm/core.md:1
msgid "@dojoengine/core"
msgstr ""

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr ""

#: src/client/npm.md:20
msgid "@dojoengine/react"
msgstr ""

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud React](https://github.com/latticexyz/mud/tree/"
"main/packages)"
msgstr ""

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr ""

#: src/client/npm.md:33
msgid "@dojoengine/create-burner"
msgstr ""

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr ""

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr ""

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""

#: src/client/npm/core.md:5
msgid "World explorers"
msgstr ""

#: src/client/npm/core.md:6
msgid "World deployers"
msgstr ""

#: src/client/npm/core.md:7
msgid "Games"
msgstr ""

#: src/client/npm/core.md:8
msgid "Anaylitics"
msgstr ""

#: src/client/npm/core.md:16
msgid "Example Usage"
msgstr ""

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"
msgstr ""

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:1
msgid "`dojoup`"
msgstr ""

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr ""

#: src/toolchain/dojoup.md:5
#, fuzzy
msgid "Installing"
msgstr "Instalación"

#: src/toolchain/dojoup.md:11 src/toolchain/katana/overview.md:22
#, fuzzy
msgid "Usage"
msgstr "### Uso del motor de Dojo"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr ""

#: src/toolchain/dojoup.md:18
msgid ""
"Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr ""

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr ""

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr ""

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/"
"dojo`, assuming you're in the home directory)"
msgstr ""

#: src/toolchain/dojoup.md:66
msgid ""
"Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""

#: src/toolchain/dojoup.md:78
#, fuzzy
msgid "Precompiled binaries"
msgstr "### Binarios precompilados"

#: src/toolchain/dojoup.md:80
#, fuzzy
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://"
"github.com/dojoengine/dojo/releases). These are better managed by using "
"[Dojoup](#using-dojoup)."
msgstr ""
"Los binarios precompilados están disponibles en la página de [GitHub "
"releases page](https://github.com/dojoengine/dojo/releases).\n"
"Es recomendable utilizar [Dojoup](#using-dojoup) para gestionarlos de manera "
"más eficiente."

#: src/toolchain/dojoup.md:84
msgid "ℹ️ **Note**"
msgstr ""

#: src/toolchain/dojoup.md:86
#, fuzzy
msgid ""
"If you're on Windows, you will need to install and use [Git BASH](https://"
"gitforwindows.org/) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install), as your terminal, since Dojoup currently does not support "
"Powershell or Cmd."
msgstr ""
"> ℹ️ **nota**\n"
">\n"
"> Si estás en Windows, deberás instalar y utilizar [Git BASH](https://"
"gitforwindows.org/) o [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install),\n"
"> como tu terminal, ya que actualmente Dojoup no es compatible con "
"Powershell o Cmd."

#: src/toolchain/sozo/overview.md:3
#, fuzzy
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of World-"
"building. In the future, it may include a GUI."
msgstr ""
"`sozo` es una poderosa herramienta de planificación de migraciones diseñada "
"para agilizar la actualización y el despliegue de los AWs (Mundos "
"Autónomos). Proporciona una interfaz de línea de comandos (CLI) binaria "
"sólida que simplifica las tareas de gestión del Mundo, permitiéndote "
"centrarte en los aspectos creativos de la construcción de Mundos. En futuras "
"versiones, se proporcionará una interfaz gráfica de usuario (GUI)."

#: src/toolchain/sozo/overview.md:5 src/toolchain/katana/overview.md:5
#, fuzzy
msgid "Features"
msgstr "## Características"

#: src/toolchain/sozo/overview.md:7
#, fuzzy
msgid ""
"**Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""
"- **Binary CLI**: Sozo ofrece una intuitiva interfaz de línea de comandos "
"(CLI), asegurando una fácil gestión de tus Mundos, ya sea que estés "
"actualizando los existentes o desplegando nuevos."

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
msgid "Installation"
msgstr "Instalación"

#: src/toolchain/sozo/overview.md:11
#, fuzzy
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-"
"start.md), our dedicated installation package manager."
msgstr ""
"El binario `sozo` puede ser instalado a través de [`dojoup`](../../getting-"
"started/installation.md#using-dojoup), nuestro gestor de paquetes de "
"instalación dedicado."

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
#, fuzzy
msgid "Installing from Source"
msgstr "### Instalación desde el código fuente"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr "Esto instalará Sozo y las dependencias requeridas en tu sistema local."

#: src/toolchain/sozo/overview.md:23 src/toolchain/katana/overview.md:60
#: src/toolchain/torii/overview.md:28
#, fuzzy
msgid "📚 **Reference**"
msgstr "## Referencias"

#: src/toolchain/sozo/overview.md:25
#, fuzzy
msgid ""
"See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulta la referencia de [sozo](../../reference/sozo/) para obtener una "
"visión completa de todos los subcomandos disponibles."

#: src/toolchain/sozo/reference.md:1
#, fuzzy
msgid "sozo reference"
msgstr "Referencias"

#: src/toolchain/sozo/reference.md:3
msgid "Project Commands"
msgstr "Comandos del Proyecto"

#: src/toolchain/sozo/reference.md:5
msgid "[init](./project-commands/init.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:6
msgid "[build](./project-commands/build.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:7
msgid "[test](./project-commands/test.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:8
msgid "[migrate](./project-commands/migrate.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:10
msgid "World Commands"
msgstr "Comandos del Mundo"

#: src/toolchain/sozo/reference.md:12
msgid "[execute](./world-commands/execute.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:13
msgid "[register](./world-commands/register.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:14
msgid "[system](./world-commands/system.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:15
msgid "[component](./world-commands/component.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:16
msgid "[events](./world-commands/events.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:17
msgid "[auth](./world-commands/auth.md)"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:1
msgid "sozo init"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:1
msgid "sozo build"
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:1
msgid "sozo test"
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "sozo migrate"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7
msgid "USAGE"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105 src/toolchain/torii/reference.md:33
#, fuzzy
msgid "OPTIONS"
msgstr "### OPCIONES"

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107 src/toolchain/torii/reference.md:35
#, fuzzy
msgid "General Options"
msgstr "#### Opciones Generales"

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"    Name of the World. At the moment, the only usage for this option is to "
"be used as a salt when deploying the World contract to avoid address "
"conflicts. This option is **required** when performing the initial migration "
"of the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
#, fuzzy
msgid "World Options"
msgstr "Comandos del Mundo"

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"    The address of the World contract.  \n"
"    ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
#, fuzzy
msgid "Starknet Options"
msgstr "#### Opciones de Starknet"

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"    The Starknet RPC endpoint. \\[default: http://localhost:5050\\]  \n"
"    ENV: `STARKNET_RPC_URL`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
msgid "Account Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"    The Starknet account address.  \n"
"    ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
msgid "Signer Options - Raw"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"    The raw private key associated with the account contract.  \n"
"    ENV: `DOJO_PRIVATE_KEY`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
msgid "Signer Options - Keystore"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
msgid ""
"`--keystore` _PATH_  \n"
"    Use the keystore in the given folder or file."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"    The keystore password. Used with --keystore.  \n"
"    ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:178 src/toolchain/katana/reference.md:186
#, fuzzy
msgid "EXAMPLES"
msgstr "### EJEMPLOS"

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "Deploying your World for the first time to a local Katana node"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "Updating a remote World after making some changes"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "sozo execute"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"    The calldata to be passed to the system that you want to execute.  \n"
"    Comma seperated values e.g., 0x12345,0x69420."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:56
msgid ""
"Executing the _position_ system which takes two values (_x_: 0x77 and _y_: "
"0x44)"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:1
msgid "sozo register"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:1
#, fuzzy
msgid "sozo system"
msgstr "Ecosistema de Cairo"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "SUBCOMMANDS"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "`get`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "Arguments"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid ""
"_`NAME`_  \n"
"    The name of the system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:30
msgid "`dependency`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:59
msgid "Get the class hash of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:65
msgid "Get the component dependencies of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:1
#, fuzzy
msgid "sozo component"
msgstr "Componentes"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
#: src/toolchain/sozo/world-commands/component.md:54
msgid ""
"_`NAME`_  \n"
"    The name of the component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:31
msgid "`schema`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:44
msgid "`entity`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
"    The keys of the entity that you want to query.  \n"
"    Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:1
msgid "sozo events"
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "sozo auth"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr ""

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""
"`katana` es un nodo de Starknet _extremadamente rápido_, diseñado para "
"admitir el desarrollo local con Dojo."

#: src/toolchain/katana/overview.md:7
#, fuzzy
msgid ""
"[Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-specs/"
"tree/v0.3.0) support"
msgstr ""
"- Soporte para [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0)"

#: src/toolchain/katana/overview.md:8
msgid "Custom methods for manipulating the blockchain states"
msgstr ""

#: src/toolchain/katana/overview.md:12
#, fuzzy
msgid ""
"`katana` binary is available via [`dojoup`](../../getting-started/quick-"
"start.md)."
msgstr ""
"El binario `katana` está disponible a través de [`dojoup`](../../getting-"
"started/installation.md#using-dojoup)."

#: src/toolchain/katana/overview.md:14
#, fuzzy
msgid "Installing from source"
msgstr "### Instalación desde el código fuente"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:62
#, fuzzy
msgid ""
"See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulta la referencia de [katana](../../reference/katana/) para obtener "
"información detallada sobre Anvil y sus capacidades."

#: src/toolchain/katana/reference.md:1
#, fuzzy
msgid "katana reference"
msgstr "referencia de katana"

#: src/toolchain/katana/reference.md:3
#, fuzzy
msgid "NAME"
msgstr "### NOMBRE"

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr ""
"katana - es una herramienta que te permite crear un nodo de testnet local "
"para implementar y probar contratos inteligentes de Starknet."

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
#, fuzzy
msgid "DESCRIPTION"
msgstr "### DESCRIPCIÓN"

#: src/toolchain/katana/reference.md:15
#, fuzzy
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"Crea un nodo de testnet local para desplegar y probar contratos inteligentes "
"de Starknet. Katana admite el despliegue y la ejecución de la versión 0 y 1 "
"de contratos de Cairo."

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""
"Esta sección cubre una extensa lista de información sobre los Modos de "
"Minería, los Métodos de RPC Soportados, los flags de Katana y sus usos. "
"Puedes ejecutar múltiples flags al mismo tiempo."

#: src/toolchain/katana/reference.md:19
#, fuzzy
msgid "Mining Modes"
msgstr "#### Modos de Minería"

#: src/toolchain/katana/reference.md:21
#, fuzzy
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""
"Los modos de minería se refieren a la frecuencia con la que se minan bloques "
"utilizando Katana. Por defecto, Katana genera automáticamente un nuevo "
"bloque tan pronto como se envía una transacción."

#: src/toolchain/katana/reference.md:23
#, fuzzy
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""
"Puedes cambiar esta configuración a la minería por intervalos si así lo "
"deseas, lo que significa que se generará un nuevo bloque en un período de "
"tiempo específico seleccionado por el usuario. Si deseas optar por este tipo "
"de minería, puedes hacerlo agregando la bandera `--block-time <tiempo-de-"
"bloque-en-segundos>`, tal como se muestra en el siguiente ejemplo."

#: src/toolchain/katana/reference.md:30
#, fuzzy
msgid "Supported Transport Layers"
msgstr "#### Capas de Transporte Soportadas"

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""
"Actualmente, solo se admite la conexión HTTP. El servidor escucha en el "
"puerto 5050 de forma predeterminada, pero se puede cambiar ejecutando el "
"siguiente comando:"

#: src/toolchain/katana/reference.md:38
#, fuzzy
msgid "Starknet Feature Compatibility"
msgstr "#### Compatibilidad de características de Starknet"

#: src/toolchain/katana/reference.md:40
#, fuzzy
msgid "Supported Transaction Type"
msgstr "##### Tipos de transacciones admitidas"

#: src/toolchain/katana/reference.md:42
msgid "Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Version"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "INVOKE"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "1"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "DECLARE"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "1, 2"
msgstr ""

#: src/toolchain/katana/reference.md:46
msgid "DEPLOY_ACCOUNT"
msgstr ""

#: src/toolchain/katana/reference.md:48
#, fuzzy
msgid "Supported RPC Methods"
msgstr "#### Métodos RPC Soportados"

#: src/toolchain/katana/reference.md:50
#, fuzzy
msgid "Starknet Methods"
msgstr "##### Metodos de Starknet"

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on [this](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katana soporta la versión **v0.3.0** de las especificaciones Starknet JSON-"
"RPC. Los métodos estándar se basan en [esta](https://github.com/starkware-"
"libs/starknet-specs/tree/v0.3.0) referencia."

#: src/toolchain/katana/reference.md:54
msgid "`starknet_blockNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:55
msgid "`starknet_blockHashAndNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:56
msgid "`starknet_getBlockWithTxs`"
msgstr ""

#: src/toolchain/katana/reference.md:57
msgid "`starknet_getBlockWithTxHashes`"
msgstr ""

#: src/toolchain/katana/reference.md:58
msgid "`starknet_getBlockTransactionCount`"
msgstr ""

#: src/toolchain/katana/reference.md:59
msgid "`starknet_getTransactionByHash`"
msgstr ""

#: src/toolchain/katana/reference.md:60
msgid "`starknet_getTransactionByBlockIdAndIndex`"
msgstr ""

#: src/toolchain/katana/reference.md:61
msgid "`starknet_getTransactionReceipt`"
msgstr ""

#: src/toolchain/katana/reference.md:62
msgid "`starknet_pendingTransactions`"
msgstr ""

#: src/toolchain/katana/reference.md:63
msgid "`starknet_getStateUpdate`"
msgstr ""

#: src/toolchain/katana/reference.md:65
msgid "`starknet_call`"
msgstr ""

#: src/toolchain/katana/reference.md:66
msgid "`starknet_estimateFee`"
msgstr ""

#: src/toolchain/katana/reference.md:68
msgid "`starknet_chainId`"
msgstr ""

#: src/toolchain/katana/reference.md:70
msgid "`starknet_getNonce`"
msgstr ""

#: src/toolchain/katana/reference.md:71
msgid "`starknet_getEvents`"
msgstr ""

#: src/toolchain/katana/reference.md:72
msgid "`starknet_getStorageAt`"
msgstr ""

#: src/toolchain/katana/reference.md:73
msgid "`starknet_getClassHashAt`"
msgstr ""

#: src/toolchain/katana/reference.md:74
msgid "`starknet_getClass`"
msgstr ""

#: src/toolchain/katana/reference.md:75
msgid "`starknet_getClassAt`"
msgstr ""

#: src/toolchain/katana/reference.md:77
msgid "`starknet_syncing`"
msgstr ""

#: src/toolchain/katana/reference.md:79
msgid "`starknet_addInvokeTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:80
msgid "`starknet_addDeclareTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:81
msgid "`starknet_addDeployAccountTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:83
#, fuzzy
msgid "Custom Methods"
msgstr "##### Métodos Personalizados"

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""
"Katana proporciona un conjunto conveniente de métodos RPC personalizados "
"para configurar rápidamente y fácilmente el nodo según las necesidades de tu "
"entorno de pruebas."

#: src/toolchain/katana/reference.md:87
#, fuzzy
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock`  \n"
"Genera un nuevo bloque que incluye todas las transacciones pendientes en el "
"momento"

#: src/toolchain/katana/reference.md:90
#, fuzzy
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`  \n"
"Obtiene el tiempo estimado para el próximo bloque"

#: src/toolchain/katana/reference.md:93
#, fuzzy
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`  \n"
"Aumenta el tiempo estimado para el próximo bloque en una cantidad específica "
"de tiempo, en segundos"

#: src/toolchain/katana/reference.md:96
#, fuzzy
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""
"`katana_setNextBlockTimestamp`  \n"
"Similar a `katana_increaseNextBlockTimestamp`, pero permite establecer el "
"tiempo exacto que deseas en el próximo bloque"

#: src/toolchain/katana/reference.md:99
#, fuzzy
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"`katana_predeployedAccounts`  \n"
"Obtiene la información de todas las cuentas pre-implementadas (predeployed "
"accounts)"

#: src/toolchain/katana/reference.md:102
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""

#: src/toolchain/katana/reference.md:109
#, fuzzy
msgid ""
"`--silent`  \n"
"     Don't print anything on startup."
msgstr ""
"`--silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; sin mostrar mensajes en la pantalla durante el "
"inicio"

#: src/toolchain/katana/reference.md:112
#, fuzzy
msgid ""
"`--no-mining`  \n"
"     Disable auto and interval mining, and mine on demand instead."
msgstr ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Desactivar la minería automática e intervalos, y en "
"su lugar minar bajo demanda"

#: src/toolchain/katana/reference.md:115
#, fuzzy
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"     Block time in seconds for interval mining."
msgstr ""
"`-b, --block-time <SEGUNDOS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Tiempo de bloque en segundos para la minería por "
"intervalos"

#: src/toolchain/katana/reference.md:118
msgid ""
"`--dump-state <PATH>`  \n"
"     Dump the state of chain on exit to the given file.  \n"
"     If the value is a directory, the state will be written to `<PATH>/state."
"bin`."
msgstr ""

#: src/toolchain/katana/reference.md:122
msgid ""
"`--load-state <PATH>`  \n"
"     Initialize the chain from a previously saved state snapshot."
msgstr ""

#: src/toolchain/katana/reference.md:125
#, fuzzy
msgid ""
"`-h, --help`  \n"
"     Print help (see a summary with '-h')."
msgstr ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir ayuda (ver un resumen con '-h')."

#: src/toolchain/katana/reference.md:128
#, fuzzy
msgid ""
"`-V, --version`  \n"
"     Print version information."
msgstr ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir información de la versión"

#: src/toolchain/katana/reference.md:131
#, fuzzy
msgid "Server Options"
msgstr "#### Opciones del servidor"

#: src/toolchain/katana/reference.md:133
#, fuzzy
msgid ""
"`-p, --port <PORT>`  \n"
"     Port number to listen on. \\[default: 5050\\]"
msgstr ""
"`-p, --port <PUERTO>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de puerto en el que escuchar [por defecto: "
"5050]."

#: src/toolchain/katana/reference.md:136
#, fuzzy
msgid ""
"`--host <HOST>`  \n"
"     The IP address the server will listen on."
msgstr ""
"`--host <ANFITRIÓN>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; La dirección IP en la que el servidor escuchará"

#: src/toolchain/katana/reference.md:141
#, fuzzy
msgid ""
"`--seed <SEED>`  \n"
"     Specify the seed for randomness of accounts to be predeployed."
msgstr ""
"`--seed <SEMILLA>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especificar la semilla para la aleatoriedad de las "
"cuentas que serán pre-implementadas (predeployed accounts)"

#: src/toolchain/katana/reference.md:144
#, fuzzy
msgid ""
"`--accounts <NUM>`  \n"
"     Number of pre-funded accounts to generate. \\[default: 10\\]"
msgstr ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de cuentas pre-financiadas para generar [por "
"defecto: 10]."

#: src/toolchain/katana/reference.md:147
msgid ""
"`--disable-fee`  \n"
"     Disable charging fee for transactions."
msgstr ""

#: src/toolchain/katana/reference.md:150
#, fuzzy
msgid "Environment Options"
msgstr "#### Opciones de entorno"

#: src/toolchain/katana/reference.md:152
#, fuzzy
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"     The chain ID. \\[default: KATANA\\]"
msgstr ""
"`--chain-id <ID_CADENA>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El ID de la cadena [por defecto: KATANA]."

#: src/toolchain/katana/reference.md:155
#, fuzzy
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"     The gas price."
msgstr ""
"`--gas-price <PRECIO_GAS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El precio del gas"

#: src/toolchain/katana/reference.md:158
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account validation logic."
msgstr ""

#: src/toolchain/katana/reference.md:161
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account execution logic."
msgstr ""

#: src/toolchain/katana/reference.md:164
msgid "Shell Completions"
msgstr ""

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr ""

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr ""

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr ""

#: src/toolchain/katana/reference.md:172
msgid "bash"
msgstr ""

#: src/toolchain/katana/reference.md:173
msgid "elvish"
msgstr ""

#: src/toolchain/katana/reference.md:174
msgid "fish"
msgstr ""

#: src/toolchain/katana/reference.md:175
msgid "powershell"
msgstr ""

#: src/toolchain/katana/reference.md:176
msgid "zsh"
msgstr ""

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr ""

#: src/toolchain/katana/reference.md:188
msgid "Create 15 dev accounts and disable transaction fee mechanism"
msgstr ""

#: src/toolchain/katana/reference.md:194
#, fuzzy
msgid "Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""
"2. Establecer el ID de cadena en SN_GOERLI y ejecutar el servidor en el "
"puerto 8545"

#: src/toolchain/katana/reference.md:200
msgid ""
"Load previously stored state and dump the state of this session to a file on "
"shutdown"
msgstr ""

#: src/toolchain/torii/overview.md:1
#, fuzzy
msgid "Torii - Networking & Indexing"
msgstr "## Torii - Redes e Indexación"

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""

#: src/toolchain/torii/overview.md:5
#, fuzzy
msgid "Dojo indexer"
msgstr "Motor de Dojo"

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr ""

#: src/toolchain/torii/overview.md:16
#, fuzzy
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/"
"quick-start.md), our dedicated installation package manager."
msgstr ""
"El binario `sozo` puede ser instalado a través de [`dojoup`](../../getting-"
"started/installation.md#using-dojoup), nuestro gestor de paquetes de "
"instalación dedicado."

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "Si prefieres instalar desde el código fuente:"

#: src/toolchain/torii/overview.md:26
#, fuzzy
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr "Esto instalará Sozo y las dependencias requeridas en tu sistema local."

#: src/toolchain/torii/overview.md:30
msgid "See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""

#: src/toolchain/torii/reference.md:1
#, fuzzy
msgid "torii reference"
msgstr "referencia de katana"

#: src/toolchain/torii/reference.md:3
msgid "Name"
msgstr ""

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr ""

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""

#: src/toolchain/torii/reference.md:19
msgid "Database URL"
msgstr ""

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""

#: src/toolchain/torii/reference.md:23
msgid ""
"The in-memory database is ephermal and only lasts as long as the indexer is "
"running. This is a fast and simple option to start the indexer for "
"development/testing."
msgstr ""

#: src/toolchain/torii/reference.md:24
msgid ""
"Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""

#: src/toolchain/torii/reference.md:37
msgid "`-w, --world`      Address of the world contract to index"
msgstr ""

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`      Starknet RPC endpoing to use \\[default: http//localhost:5050\\]"
msgstr ""

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`      Specify a local manifest to initialize from"
msgstr ""

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`      Database URL (read more above) "
"\\[default: sqlite::memory:\\]"
msgstr ""

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`      Specify a block to start indexing "
"from, ignored if stored head exists \\[default: 0\\]"
msgstr ""

#: src/toolchain/torii/reference.md:52
msgid "`-h, --help`      Print help"
msgstr ""

#: src/toolchain/torii/reference.md:55
msgid "`-V, --version`      Print version"
msgstr ""

#: src/deployment/locally.md:1
msgid "Deploying Locally"
msgstr ""

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""

#: src/deployment/locally.md:5
msgid "Katana Deployments"
msgstr ""

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr ""

#: src/deployment/locally.md:9
msgid ""
"This assumes you have followed the [Quick Start](./getting-started/quick-"
"start.md) guide and have a project initialized."
msgstr ""

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr ""

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr ""

#: src/deployment/locally.md:19
msgid "Deploying to Katana"
msgstr ""

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr ""

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""

#: src/deployment/remote.md:1
msgid "Deployment to Remote Network"
msgstr ""

#: src/deployment/remote.md:3
msgid "_IMPORTANT: Dojo is unaudited. Use at your own risk._"
msgstr ""

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr ""

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:33
msgid "Remote Katana"
msgstr ""

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""

#: src/deployment/remote.md:37
msgid "**todo**: add instructions for deploying to remote katana"
msgstr ""

#: src/deployment/remote.md:40
msgid "Madara"
msgstr ""

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr ""

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr ""

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr ""

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:59
msgid "Starknet"
msgstr ""

#: src/deployment/remote.md:61
msgid "**todo**: add instructions for deploying to remote Starknet"
msgstr ""

#: src/tutorial/onchain-chess/index.md:1
msgid "Building a Chess Game"
msgstr ""

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr ""

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""

#: src/tutorial/onchain-chess/index.md:11
msgid "What are we building?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""

#: src/tutorial/onchain-chess/index.md:15
msgid "A system to spawn all the chess pieces"
msgstr ""

#: src/tutorial/onchain-chess/index.md:16
msgid "A system to make pieces move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:17
msgid "Add some functions to check a legal move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:18
msgid "Play chess ♟♙ - integration test!"
msgstr ""

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/"
"rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""

#: src/tutorial/onchain-chess/index.md:24
msgid "What after this guide?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-"
"dojo.md) chapter to gain a basic understanding of the Dojo game._"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "Initializing the Project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "Cleaning Up the Boilerplate"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:42
#, fuzzy
msgid "Basic components"
msgstr "Componentes"

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:46
msgid ""
"Every square of the chess board (e.g., A1) will be treated as an entity. If "
"a piece exists on a square, the square entity will hold that piece."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this [chapter]"
"(../../cairo/components.md)."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:78
#, fuzzy
msgid "Basic systems"
msgstr "Ecosistema de Cairo"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:111
msgid "Compile your project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "Run test"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:189
#, fuzzy
msgid "Add more components"
msgstr "## Componentes"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:193
#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
msgid "Requirements"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:195
msgid "`Color` enum enum with values White and Black"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:196
#, fuzzy
msgid "`Game` component:"
msgstr "## Componentes"

#: src/tutorial/onchain-chess/0-setup.md:205
msgid "`GameTurn` component:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:212
msgid ""
"We will later set game entity composed of the `Game` and `GameTurn` "
"components."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:213
msgid "Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:215
msgid ""
"Try to solve on your own, and before you move on check the answer below."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:1
msgid "1. Initiate System"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:5
msgid "What is `initiate_system`?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"initiate.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:17
msgid ""
"Implement the game entity, comprised of the `Game` component and `GameTurn` "
"component we created in the previous step."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:18
msgid ""
"Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:19
msgid "Run `sozo test` and pass all the tests."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "Test Flow"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"Spawn the test world that imports the components and systems used in testing."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:24
msgid ""
"Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:25
msgid ""
"Retrieve the game entity and piece entity created during `initiate_system`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:26
msgid "Ensure the game has been correctly created."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:27
msgid "Verify that each `Piece` is located in the correct `Square`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
msgid "Unit Tests"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
msgid "Need help?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community]"
"(https://discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) for chapter 1 here."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:1
msgid "2. Move System"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:5
msgid "What is `move_system`?"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"move.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:13
msgid "Write an `execute` function in the system with the following inputs:"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:25
msgid ""
"Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:27
msgid "Run `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:31
msgid "Follow the same logic as `test_initiate` from the previous chapter."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:32
msgid "Move the White Knight from (1,0) to (2,2) using the `move_system`."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:33
msgid ""
"Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:5
msgid "If the next move goes outside the board."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:6
msgid "If there's a piece that can be captured."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:7
msgid "If the next move is allowed for the type of piece."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:8
msgid "If the user can allow to make a action (based on the piece's color)."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:9
msgid "... You can also add other custom check functions."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:11
msgid "Make Check Functions"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:15
msgid "See if the next spot is allowed for the type of piece moving."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:23
msgid "See if the next spot is still on the board."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:29
msgid ""
"See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:35
msgid ""
"You can also add other check functions to be extra sure the move is allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:85
msgid "Testing Each Function"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:1
msgid "4. Test Contract"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:7
msgid "Spawn `white_pawn_1` to (0,1)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:8
msgid "Move `white_pawn_1` to (0,3)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:9
msgid "Move `black_pawn_2` to (1,6)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:10
msgid "Move `white_pawn_1` to (0,4)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:11
msgid "Move `black_pawn_2` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:12
msgid "Move `white_pawn_1` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:13
msgid "Capture `black_pawn_2`"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:19
msgid "Copy the test below and add it to your `src/tests.cairo` file."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:20
msgid ""
"Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:22
msgid "Full Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:143
msgid "Diving into the Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:212
msgid "Congratulations!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:217
msgid ""
"Add a checkmate feature. Our game doesn't end now, so decide when it should!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:218
msgid ""
"Include special moves like castling, En Passant Capture, or Pawn Promotion."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:219
msgid ""
"Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo community](https://"
"discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/misc/contributors.md:1
#, fuzzy
msgid "Contributing to Dojo Book"
msgstr "## Contribuyendo al Libro de Dojo"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""
"Conforme el motor de Dojo avanza y se desarrolla, es fundamental que el "
"Libro de Dojo se mantenga al día con estos avances. Actualizar y "
"perfeccionar el libro garantiza que siga siendo un recurso relevante y "
"valioso para aquellos interesados en comprender y utilizar las últimas "
"características y capacidades del motor de Dojo. ¡Toda ayuda es bienvenida!"

#: src/misc/contributors.md:5
#, fuzzy
msgid "The purpose of the book"
msgstr "### El propósito del libro es"

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""
"El libro de Dojo está diseñado para ser un recurso completo que atienda a "
"usuarios de varios niveles de experiencia. Su objetivo es servir como una "
"guía introductoria para aquellos que son nuevos en Dojo y sus paquetes "
"complementarios, así como una referencia para usuarios más experimentados "
"que buscan profundizar su comprensión de las características y capacidades "
"del motor."

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "El libro está dividido en varios capítulos principales:"

#: src/misc/contributors.md:11
msgid "Framework Theory"
msgstr ""

#: src/misc/contributors.md:13
#, fuzzy
msgid "Building a World"
msgstr "### Compilando desde el código fuente"

#: src/misc/contributors.md:15
#, fuzzy
msgid "Code of Conduct"
msgstr "### Código de conducta"

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of Conduct](https://www.rust-lang.org/"
"policies/code-of-conduct)."
msgstr ""
"El libro sigue el [Rust Code of Conduct](https://www.rust-lang.org/policies/"
"code-of-conduct)."

#: src/misc/contributors.md:19
#, fuzzy
msgid "Ways to contribute"
msgstr "### Formas de contribuir"

#: src/misc/contributors.md:21
msgid "Issues"
msgstr ""

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""
"Si consideras que falta algún contenido o que alguna información está "
"desactualizada, no dudes en abrir un 'issue' al respecto. Si encuentras "
"varias partes del contenido que necesitan ser complementadas, por favor, "
"abre un 'issue' separado para cada una."

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""
"Luego, los 'issues' serán etiquetados para que otros colaboradores puedan "
"encontrar áreas de trabajo que les interesen más fácilmente."

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""
"El 'issue' debe contener lo que falta o lo que podría mejorar, con todos los "
"detalles que consideres necesarios."

#: src/misc/contributors.md:29
msgid "Pull requests"
msgstr ""

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""
"Siéntete libre de contribuir con cambios al libro abriendo un PR (pull "
"request). Todo es bienvenido, desde reformular una oración, corregir un "
"error tipográfico hasta agregar nuevas secciones o capítulos."

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""
"Cuando tu pull request esté abierto, otros colaboradores lo revisarán y "
"podrían solicitar cambios. ¡No te desanimes!"

#: src/misc/contributors.md:35
#, fuzzy
msgid "Writing style"
msgstr "### Estilo de escritura"

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr ""
"Esta sección documenta algunos estándares de escritura utilizados a lo largo "
"del libro."

#: src/misc/contributors.md:39
#, fuzzy
msgid "Chapters start with a second level heading"
msgstr "#### Los capítulos comienzan con un encabezado de segundo nivel"

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "Nosotras usamos:"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr "Nosotras no usamos:"

#~ msgid "Introduction"
#~ msgstr "Introducción"

#~ msgid "Storage"
#~ msgstr "Almacenamiento"

#~ msgid "Appendix"
#~ msgstr "Apéndice"

#~ msgid ""
#~ "Dojo is a provable game engine with an integrated toolchain, designed for "
#~ "creating onchain games and autonomous worlds using [Cairo 1.0](https://"
#~ "github.com/starkware-libs/cairo). It employs an [entity component system]"
#~ "(https://en.wikipedia.org/wiki/Entity_component_system) and a [diamond "
#~ "pattern](https://eips.ethereum.org/EIPS/eip-2535), facilitating a "
#~ "modular, scalable world. Worlds grow via the addition of Components "
#~ "(state) and Systems (logic). Our architectural design is greatly "
#~ "influenced by the brilliant [Bevy](https://bevyengine.org/) engine."
#~ msgstr ""
#~ "Dojo es un motor de juegos demostrables con una herramienta integrada, "
#~ "diseñada para crear juegos y mundos autónomos en la cadena de bloques "
#~ "utilizando [Cairo 1.0](https://github.com/starkware-libs/cairo). Emplea "
#~ "un [sistema de componentes de entidades](https://en.wikipedia.org/wiki/"
#~ "Entity_component_system) y el [patrón diamante](https://eips.ethereum.org/"
#~ "EIPS/eip-2535), facilitando un mundo modular y escalable. Los mundos "
#~ "crecen mediante la adición de Componentes (estado) y Sistemas (lógica). "
#~ "Nuestro diseño arquitectónico está fuertemente influenciado por el "
#~ "brillante motor [Bevy](https://bevyengine.org/)."

#~ msgid "#### Key Features"
#~ msgstr "#### Características clave"

#~ msgid ""
#~ "- Entity Component System (ECS) built on [Cairo 1.0](https://github.com/"
#~ "starkware-libs/cairo)\n"
#~ "- [Sozo](./framework/sozo/overview.md) world migration planner\n"
#~ "- [Torii](./framework/torii/overview.md) networking and indexing stack\n"
#~ "- [Katana](./framework/katana/overview.md) RPC development network\n"
#~ "- Typed SDKs"
#~ msgstr ""
#~ "- Sistema de Componentes de Entidades (ECS) construido en [Cairo 1.0]"
#~ "(https://github.com/starkware-libs/cairo)\n"
#~ "- [Sozo](./framework/sozo/overview.md) planificador de migraciones de "
#~ "mundos\n"
#~ "- [Torii](./framework/torii/overview.md) pila de red e indexación\n"
#~ "- [Katana](./framework/katana/overview.md) red de desarrollo RPC\n"
#~ "- SDKs tipados"

#~ msgid "### Why Cairo & Starknet?"
#~ msgstr "### ¿Por qué Cairo y StarkNet?"

#~ msgid "### Vision"
#~ msgstr "### Visión"

#~ msgid ""
#~ "Dojo is a bold work in progress, aimed at empowering developers to "
#~ "construct onchain games and Autonomous Worlds (AWs) within hours, not "
#~ "weeks."
#~ msgstr ""
#~ "Dojo es un audaz trabajo en progreso, con el objetivo de capacitar a los "
#~ "desarrolladores para construir juegos en la cadena y Mundos Autónomos "
#~ "(AWs) en cuestión de horas, no semanas."

#~ msgid "## Installation"
#~ msgstr "## Instalación"

#~ msgid "### Using Dojoup"
#~ msgstr "### Utilizando Dojoup"

#~ msgid "Open your terminal and run the following command:"
#~ msgstr "Abre tu terminal y ejecuta el siguiente comando:"

#~ msgid ""
#~ "Running `dojoup` by itself will install the latest (nightly) [precompiled "
#~ "binaries](#precompiled-binaries): `sozo`, `katana`, and `torii`.\n"
#~ "See `dojoup --help` for more options, like installing from a specific "
#~ "version or commit."
#~ msgstr ""
#~ "Ejecutar `dojoup` por sí mismo instalará las últimas versiones (nightly) "
#~ "de [binarios precompilados](#precompiled-binaries): `sozo`, `katana`, and "
#~ "`torii`.\n"
#~ "Consulta `dojoup --help` para más opciones, como instalar desde una "
#~ "versión o commit específico."

#~ msgid "#### Prerequisites"
#~ msgstr "#### Requisitos previos"

#~ msgid "# Dojo Engine - Getting Started Guide"
#~ msgstr "# Motor de Dojo - Guía de Inicio"

#~ msgid ""
#~ "This README guides you through the process of setting up your local "
#~ "development environment for Dojo."
#~ msgstr ""
#~ "Este archivo README te guiará a través del proceso de configurar tu "
#~ "entorno de desarrollo local para Dojo."

#~ msgid "## Clone the Repository"
#~ msgstr "## Clonar el repositorio"

#~ msgid "First, clone the repository to your local machine:"
#~ msgstr "Primero, clona el repositorio en tu máquina local:"

#~ msgid "## Setup Guide"
#~ msgstr "## Guía de configuración"

#~ msgid ""
#~ "For proper linting and syntax highlighting, you should install the Cairo "
#~ "1.0 extension for Visual Studio Code."
#~ msgstr ""
#~ "Para obtener un correcto resaltado de sintaxis y linting, debes instalar "
#~ "la extensión de Cairo 1.0 para Visual Studio Code."

#~ msgid ""
#~ "- Clone the Cairo repository somewhere on your machine (make sure not to "
#~ "clone within the Dojo directory)."
#~ msgstr ""
#~ "- Clona el repositorio de Cairo en algún lugar de tu máquina (asegúrate "
#~ "de no clonarlo dentro del directorio de Dojo)."

#~ msgid ""
#~ "- Install the Cairo Language Server extension. Here's a step-by-step "
#~ "guide, or you can follow the [official instructions](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."
#~ msgstr ""
#~ "- Instala la extensión Cairo Language Server. Aquí tienes una guía paso a "
#~ "paso, o puedes seguir las [instrucciones oficiales](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."

#~ msgid "Navigate to the vscode-cairo directory:"
#~ msgstr "Navega al directorio vscode-cairo:"

#~ msgid "Install the required packages:"
#~ msgstr "Instala los paquetes necesarios:"

#~ msgid "Package the extension:"
#~ msgstr "Empaqueta la extensión:"

#~ msgid "Install the extension:"
#~ msgstr "Instala la extensión:"

#~ msgid ""
#~ "> **Mac Tip:** If you don't have the `code` command, in VSCode do "
#~ "`Cmd+Shift+P` and type 'shell command' to find the Shell Command: Install "
#~ "'code' command in PATH command."
#~ msgstr ""
#~ "> **Mac Tip:** Si no tienes el comando `code`, en VSCode presiona "
#~ "`Cmd+Shift+P` y escribe 'shell command' para encontrar el comando: "
#~ "Instale el comando 'code' en el PATH."

#~ msgid ""
#~ "The Cairo language server should now be installed globally in your Visual "
#~ "Studio Code. If you have the server enabled, Scarb should automatically "
#~ "pick this up and start linting your Cairo files."
#~ msgstr ""
#~ "El servidor de lenguaje de Cairo debería estar instalado globalmente en "
#~ "tu Visual Studio Code ahora. Si tienes el servidor habilitado, Scarb "
#~ "debería detectarlo automáticamente y comenzar a realizar el análisis de "
#~ "estilo en tus archivos de Cairo."

#~ msgid ""
#~ "- [Overview](./framework/cairo/overview.md)\n"
#~ "- [World](./framework/cairo/world.md)\n"
#~ "- [Components](./framework/cairo/components.md)\n"
#~ "- [Systems](./framework/cairo/systems.md)\n"
#~ "- [Entities](./framework/cairo/entities.md)\n"
#~ "- [Commands](./framework/cairo/commands.md)\n"
#~ "- [Storage](./framework/cairo/storage.md)"
#~ msgstr ""
#~ "- [Visión general](./framework/cairo/overview.md)\n"
#~ "- [Mundo](./framework/cairo/world.md)\n"
#~ "- [Componentes](./framework/cairo/components.md)\n"
#~ "- [Sistemas](./framework/cairo/systems.md)\n"
#~ "- [Entidades](./framework/cairo/entities.md)\n"
#~ "- [Comandos](./framework/cairo/commands.md)\n"
#~ "- [Almacenamiento](./framework/cairo/storage.md)"

#~ msgid ""
#~ "Dojo comes with batteries included to power your games. There are 3 core "
#~ "tools which you will use to build your worlds."
#~ msgstr ""
#~ "Dojo viene con herramientas incluidas para impulsar tus juegos. Hay 3 "
#~ "herramientas principales que utilizarás para construir tus mundos."

#~ msgid "## Overview"
#~ msgstr "## Visión general"

#~ msgid "### Understanding the ECS in Dojo"
#~ msgstr "### Comprendiendo el ECS en Dojo"

#~ msgid ""
#~ "The Entity Component System (ECS) forms the backbone of the Dojo engine. "
#~ "Here's an overview of its core elements:"
#~ msgstr ""
#~ "El Sistema de Componentes de Entidades (ECS) es el corazón del motor de "
#~ "Dojo. Aquí tienes una descripción general de sus elementos principales:"

#~ msgid ""
#~ "1. **Entities**: Unique objects that can bear multiple components. They "
#~ "are identifiable through unique IDs.\n"
#~ "2. **Components**: Diverse attributes of an entity, such as geometry, "
#~ "physics, and hit points. Components are exclusively responsible for data "
#~ "storage.\n"
#~ "3. **Systems**: Segments of code that manage entities and alter "
#~ "components.\n"
#~ "4. **Queries**: Utilized by systems to select entities based on the "
#~ "associated components.\n"
#~ "5. **World**: A comprehensive container for entities, components, "
#~ "systems, and queries."
#~ msgstr ""
#~ "1. **Entidades**: Objetos únicos que pueden tener múltiples componentes. "
#~ "Se identifican mediante identificadores únicos (IDs).\n"
#~ "2. **Componentes**: Diversos atributos de una entidad, como geometría, "
#~ "física y puntos de vida. Los componentes son exclusivamente responsables "
#~ "del almacenamiento de datos.\n"
#~ "3. **Sistemas**: Segmentos de código que administran entidades y "
#~ "modifican componentes.\n"
#~ "4. **Consultas (Queries)**: Utilizadas por los sistemas para seleccionar "
#~ "entidades en función de los componentes asociados.\n"
#~ "5. **Mundo (World)**: Un contenedor completo para entidades, componentes, "
#~ "sistemas y consultas."

#~ msgid "### Building an Autonomous World with Dojo"
#~ msgstr "### Construyendo un Mundo Autónomo con Dojo"

#~ msgid "Follow these steps to effectively create a Dojo world:"
#~ msgstr "Sigue estos pasos para crear eficazmente un mundo con Dojo:"

#~ msgid ""
#~ "1. **Conceptualize Entities**: Visualize the entities that will populate "
#~ "your world.\n"
#~ "2. **Recognize Shared Attributes**: Determine common characteristics of "
#~ "your entities, such as position, name, or health.\n"
#~ "3. **Construct Reusable Components**: Create versatile components derived "
#~ "from these shared attributes.\n"
#~ "4. **Develop Specialized Systems**: Design systems that are adept at "
#~ "performing a specific task."
#~ msgstr ""
#~ "1. **Conceptualiza las Entidades**: Visualiza las entidades que poblarán "
#~ "tu mundo.\n"
#~ "2. **Identifica Atributos Compartidos**: Determina las características "
#~ "comunes de tus entidades, como posición, nombre o salud.\n"
#~ "3. **Construye Componentes Reutilizables**: Crea componentes versátiles "
#~ "derivados de estos atributos compartidos.\n"
#~ "4. **Desarrolla Sistemas Especializados**: Diseña sistemas que sean "
#~ "hábiles para realizar tareas específicas."

#~ msgid ""
#~ "To illustrate, here's an example of a basic design that utilizes "
#~ "components and systems to create four distinct entities:"
#~ msgstr ""
#~ "Para ilustrar, aquí tienes un ejemplo de un diseño básico que utiliza "
#~ "componentes y sistemas para crear cuatro entidades distintas:"

#~ msgid "## World"
#~ msgstr "## Mundo"

#~ msgid "## Authorization"
#~ msgstr "## Autorización"

#~ msgid "__todo__"
#~ msgstr "__Próximamente__"

#~ msgid ""
#~ "Components serve as the foundation for defining the world's structure, "
#~ "encapsulating state for systems to mutate. For instance, a Position "
#~ "component can be implemented as a struct, exposing `is_zero` and "
#~ "`is_equal` methods. Dojo compiles these components into contracts that "
#~ "can be declared and installed within a world, enabling the creation of "
#~ "diverse and customizable environments."
#~ msgstr ""
#~ "Los componentes sirven como base para definir la estructura del mundo, "
#~ "encapsulando el estado para que los sistemas puedan modificarlo. Por "
#~ "ejemplo, un componente de Posición se puede implementar como una "
#~ "estructura, exponiendo métodos como `is_zero` e `is_equal`. Dojo compila "
#~ "estos componentes en contratos que pueden ser declarados e instalados "
#~ "dentro de un mundo, lo que permite la creación de entornos diversos y "
#~ "personalizables."

#~ msgid ""
#~ "Suppose you plan to create two entities that move around the map and are "
#~ "fundamentally different from each other, except for the fact that they "
#~ "both exist within the world. In this case, you could create a shared "
#~ "Position component for both entities. This demonstrates the power of the "
#~ "Entity Component System (ECS) abstraction: by writing a single component, "
#~ "you can reuse it across multiple diverse entities, promoting modularity "
#~ "and flexibility within your world design."
#~ msgstr ""
#~ "Supongamos que planeas crear dos entidades que se mueven por el mapa y "
#~ "son fundamentalmente diferentes entre sí, excepto por el hecho de que "
#~ "ambas existen dentro del mundo. En este caso, podrías crear un componente "
#~ "de \"Posición\" compartido para ambas entidades. Esto demuestra el poder "
#~ "de la abstracción del Sistema de Componentes de Entidades(ECS): al "
#~ "escribir un solo componente, puedes reutilizarlo en múltiples entidades "
#~ "diversas, fomentando la modularidad y flexibilidad en el diseño de tu "
#~ "mundo."

#~ msgid "## Systems"
#~ msgstr "## Sistemas"

#~ msgid ""
#~ "Systems represent functions that operate on the world state. They take "
#~ "input from the user, retrieve the current state from the world, compute a "
#~ "state transition, and apply it. Each system has a single entry point, the "
#~ "execute function. To streamline interaction with the world, systems can "
#~ "utilize\n"
#~ "commands."
#~ msgstr ""
#~ "Los Sistemas representan funciones que operan sobre el estado del mundo. "
#~ "Toman información del usuario, obtienen el estado actual del mundo, "
#~ "calculan una transición de estado y la aplican. Cada sistema tiene un "
#~ "único punto de entrada, la función `execute`. Para simplificar la "
#~ "interacción con el mundo, los sistemas pueden utilizar comandos."

#~ msgid "## Entities"
#~ msgstr "## Entidades"

#~ msgid "Finally, lets move the character with the `MoveSystem`."
#~ msgstr "Finalmente, movamos al personaje con el `MoveSystem`."

#~ msgid "## Commands"
#~ msgstr "## Comandos"

#~ msgid "# Storage"
#~ msgstr "# Almacenamiento"

#~ msgid ""
#~ "In a Dojo Autonomous World, the `World` contract serves as the central "
#~ "store that manages and maintains the overall state. No state is "
#~ "maintained at the component level, this allows a clean split in logic and "
#~ "state. Most developers will not need to touch the storage methods, every "
#~ "part of the world can just be maintained via the [commands](./commands."
#~ "md)."
#~ msgstr ""
#~ "En un Mundo Autónomo de Dojo, el contrato `World` sirve como la tienda "
#~ "central que administra y mantiene el estado general. No se mantiene "
#~ "ningún estado a nivel de componente, lo que permite una división clara "
#~ "entre la lógica y el estado. La mayoría de los desarrolladores no "
#~ "necesitarán manipular los métodos de almacenamiento, ya que cada parte "
#~ "del mundo puede ser gestionada mediante los [comandos](./commands.md)."

#~ msgid "## Detailed overview of Storage"
#~ msgstr "## Descripción detallada del Almacenamiento"

#~ msgid ""
#~ "State is maintained via a generated partition when you create a "
#~ "component. The compiler calculates the size of the component along with "
#~ "the key you have used and creates a partition within the world. Think of "
#~ "the partition as a table which can be read from and written to."
#~ msgstr ""
#~ "El estado se mantiene mediante una partición generada al crear un "
#~ "componente. El compilador calcula el tamaño del componente junto con la "
#~ "clave que has utilizado, y crea una partición dentro del mundo. Puedes "
#~ "pensar en la partición como una tabla a la cual se puede leer y escribir."

#~ msgid "### Features"
#~ msgstr "### Características"

#~ msgid ""
#~ "Torii serves as a comprehensive indexing and networking layer for dojo "
#~ "worlds. It systematically organizes the state of dojo worlds, "
#~ "facilitating efficient querying for clients."
#~ msgstr ""
#~ "Torii actúa como una capa completa de indexación y redes para los mundos "
#~ "de Dojo. Organiza sistemáticamente el estado de los mundos de Dojo, "
#~ "facilitando consultas eficientes para los clientes."

#~ msgid "### Indexer"
#~ msgstr "### Indexación"

#~ msgid "__coming soon__"
#~ msgstr "__Próximamente__"

#~ msgid ""
#~ "-   [sozo Commands](./sozo/)\n"
#~ "-   [katana Reference](./katana/)"
#~ msgstr ""
#~ "-   [Comandos sozo](./sozo/)\n"
#~ "-   [Referencias katana](./katana/)"

#~ msgid "## sozo Commands"
#~ msgstr "## Comandos de sozo"

#~ msgid ""
#~ "-   [Project Commands](./project-commands.md)\n"
#~ "-   [World Commands](./world-commands.md)"
#~ msgstr ""
#~ "-   [Comandos de Proyecto](./project-commands.md)\n"
#~ "-   [Comandos de Mundo](./world-commands.md)"

#~ msgid "## Project Commands"
#~ msgstr "## Comandos de Proyecto"

#~ msgid "## World Commands"
#~ msgstr "## Comandos de Mundo"

#~ msgid "### SYNOPSIS"
#~ msgstr "### SINOPSIS"

#~ msgid ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Allow transaction max fee to be zero"
#~ msgstr ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Permitir que la tarifa máxima de la transacción "
#~ "sea cero"

#~ msgid "1. Set the number of accounts to 15 and allow zero fee transaction"
#~ msgstr ""
#~ "1. Establecer el número de cuentas en 15 y permitir transacciones sin "
#~ "tarifas"

#~ msgid ""
#~ "- Framework Theory\n"
#~ "- Getting Started\n"
#~ "- Building a World"
#~ msgstr ""
#~ "- Teoría del Framework\n"
#~ "- Comenzando\n"
#~ "- Construyendo un Mundo"
